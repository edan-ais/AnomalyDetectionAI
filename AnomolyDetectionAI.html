<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Interface</title>
    <style>
        :root {
            --primary-color: #6366f1;
            --bg-color: #f0f2f5;
            --popup-bg: #ffffff;
            --sidebar-bg: #f8fafc;
            --chat-bg: white;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --hover-color: #e0e7ff;
            --message-user-bg: #e0e7ff;
            --message-ai-bg: #f1f5f9;
            --popup-shadow: rgba(0, 0, 0, 0.1);
            --danger-color: #ef4444;
            --warning-bg: #fff7ed;
            --warning-border: #fdba74;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            display: flex;
            width: 90%;
            max-width: 1200px;
            height: 85vh;
            background-color: var(--popup-bg);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 10px 25px var(--popup-shadow);
        }

        .sidebar {
            width: 250px;
            background-color: var(--sidebar-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-actions {
            display: flex;
            gap: 8px;
        }

        .sidebar-title {
            font-weight: 600;
            font-size: 16px;
        }

        .new-chat-btn, .sweep-all-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            border: none;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .new-chat-btn {
            background-color: var(--primary-color);
            color: white;
        }

        .new-chat-btn:hover {
            background-color: #5558d6;
        }

        .sweep-all-btn {
            background-color: var(--text-secondary);
            color: white;
        }

        .sweep-all-btn:hover {
            background-color: var(--danger-color);
        }

        .chats-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .chat-item {
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        .chat-item:hover {
            background-color: var(--hover-color);
        }

        .chat-item.active {
            background-color: var(--hover-color);
            border-left: 3px solid var(--primary-color);
        }

        .chat-item-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .delete-chat-btn {
            opacity: 0;
            color: var(--text-secondary);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            transition: opacity 0.2s, color 0.2s;
        }

        .chat-item:hover .delete-chat-btn {
            opacity: 1;
        }

        .delete-chat-btn:hover {
            color: var(--danger-color);
        }

        .main-content {
            flex: 1;
            display: flex;
            height: 100%;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
            background-color: var(--chat-bg);
            position: relative;
        }

        .chat-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .message {
            max-width: 80%;
            padding: 12px 16px;
            border-radius: 12px;
            line-height: 1.5;
        }

        .message.user {
            align-self: flex-end;
            background-color: var(--message-user-bg);
            border-bottom-right-radius: 4px;
        }

        .message.ai {
            align-self: flex-start;
            background-color: var(--message-ai-bg);
            border-bottom-left-radius: 4px;
        }

        .input-container {
            padding: 16px;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 8px;
        }

        .message-input {
            flex: 1;
            padding: 12px 16px;
            border-radius: 24px;
            border: 1px solid var(--border-color);
            resize: none;
            outline: none;
            font-size: 14px;
            max-height: 120px;
            min-height: 48px;
            transition: border-color 0.2s;
        }

        .message-input:focus {
            border-color: var(--primary-color);
        }

        .upload-btn {
            width: 48px;
            height: 48px;
            border-radius: 24px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            font-size: 20px;
        }

        .upload-btn:hover {
            background-color: #5558d6;
        }

        .send-btn {
            width: 48px;
            height: 48px;
            border-radius: 24px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .send-btn:hover {
            background-color: #5558d6;
        }

        .send-btn:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        #file-input {
            display: none;
        }

        .uploaded-file {
            margin-top: 8px;
            padding: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 6px;
            background-color: var(--message-user-bg);
        }

        .file-preview {
            max-width: 100px;
            max-height: 100px;
            border-radius: 4px;
        }

        .file-name {
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .remove-file-btn {
            color: var(--text-secondary);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            transition: color 0.2s;
        }

        .remove-file-btn:hover {
            color: var(--danger-color);
        }

        .warning-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
        }

        .warning-modal.show {
            opacity: 1;
            visibility: visible;
        }

        .warning-dialog {
            background-color: white;
            border-radius: 8px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .warning-header {
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 16px;
            color: var(--danger-color);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .warning-content {
            margin-bottom: 24px;
            line-height: 1.5;
            color: var(--text-primary);
        }

        .warning-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .btn {
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }

        .btn-cancel {
            background-color: #f1f5f9;
            color: var(--text-primary);
        }

        .btn-cancel:hover {
            background-color: #e2e8f0;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-danger:hover {
            background-color: #dc2626;
        }

        .preview-container {
            width: 300px;
            background-color: var(--sidebar-bg);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
            overflow: hidden;
        }

        .preview-container.hidden {
            width: 0;
        }

        .preview-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .preview-content {
            flex: 1;
            overflow: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .preview-placeholder {
            color: var(--text-secondary);
            text-align: center;
            font-size: 14px;
            max-width: 80%;
        }

        .preview-image {
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .document-preview {
            width: 100%;
            height: 70vh;
            border: 1px solid var(--border-color);
            border-radius: 8px;
        }

        .close-preview-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 18px;
        }

        .close-preview-btn:hover {
            color: var(--danger-color);
        }

        .uploaded-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
            padding: 0 16px;
        }

        @media (max-width: 992px) {
            .preview-container {
                position: absolute;
                right: 0;
                height: 100%;
                z-index: 5;
                box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .app-container {
                width: 95%;
                height: 90vh;
            }
            
            .sidebar {
                position: absolute;
                transform: translateX(-100%);
                z-index: 10;
                height: 90vh;
                border-radius: 12px 0 0 12px;
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            }
            
            .sidebar.show {
                transform: translateX(0);
            }
            
            .toggle-sidebar {
                display: block;
                position: absolute;
                top: 16px;
                left: 16px;
                z-index: 5;
            }

            .preview-container {
                width: 100%;
            }
        }

        .toggle-sidebar {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .toggle-preview {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4;
        }

        @media (max-width: 992px) {
            .toggle-preview {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">AI Chat</div>
                <div class="sidebar-actions">
                    <button class="new-chat-btn" id="new-chat-btn" title="New Chat">+</button>
                    <button class="sweep-all-btn" id="sweep-all-btn" title="Delete All Chats">🗑️</button>
                </div>
            </div>
            <div class="chats-list" id="chats-list">
                <!-- Chat items will be added here dynamically -->
            </div>
        </div>

        <button class="toggle-sidebar" id="toggle-sidebar">≡</button>

        <div class="main-content">
            <div class="chat-container">
                <div class="chat-header" id="chat-header">New Chat</div>
                <div class="messages-container" id="messages-container">
                    <!-- Messages will be added here dynamically -->
                </div>
                <div class="uploaded-container" id="uploaded-container">
                    <!-- Uploaded files will appear here -->
                </div>
                <div class="input-container">
                    <input type="file" id="file-input" multiple accept="image/*,.pdf,.doc,.docx,.txt">
                    <button class="upload-btn" id="upload-btn">📄</button>
                    <textarea class="message-input" id="message-input" placeholder="Type a message..." rows="1"></textarea>
                    <button class="send-btn" id="send-btn">➤</button>
                </div>
                <button class="toggle-preview" id="toggle-preview">👁️</button>
            </div>

            <div class="preview-container hidden" id="preview-container">
                <div class="preview-header">
                    <span>Document Preview</span>
                    <button class="close-preview-btn" id="close-preview-btn">×</button>
                </div>
                <div class="preview-content" id="preview-content">
                    <div class="preview-placeholder">
                        Upload a document or image to see a preview here
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="warning-modal" id="warning-modal">
        <div class="warning-dialog">
            <div class="warning-header">
                <span>⚠️</span>
                <span>Warning: Delete All Chats</span>
            </div>
            <div class="warning-content">
                This action will permanently delete all chats and chat history. This cannot be undone. Are you sure you want to continue?
            </div>
            <div class="warning-actions">
                <button class="btn btn-cancel" id="cancel-delete-all">Cancel</button>
                <button class="btn btn-danger" id="confirm-delete-all">Delete All</button>
            </div>
        </div>
    </div>

    <script>
// OpenAI API Configuration
const OPENAI_API_KEY = "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"; // Replace with your actual API key
const OPENAI_API_URL = "https://api.openai.com/v1/chat/completions";
const OPENAI_MODEL = "gpt-4o"; // or "gpt-4-turbo" or "gpt-3.5-turbo" based on your needs

        // Database setup for IndexedDB
        let db;
        const dbName = "AIChat";
        const dbVersion = 1;
        const chatStoreName = "chats";
        
        // Open IndexedDB
        const request = indexedDB.open(dbName, dbVersion);
        
        request.onerror = (event) => {
            console.error("Database error:", event.target.error);
            // Fall back to localStorage if IndexedDB fails
            alert("Could not open database. Falling back to localStorage.");
        };
        
        request.onupgradeneeded = (event) => {
            db = event.target.result;
            if (!db.objectStoreNames.contains(chatStoreName)) {
                const store = db.createObjectStore(chatStoreName, { keyPath: "id" });
                store.createIndex("name", "name", { unique: false });
                store.createIndex("createdAt", "createdAt", { unique: false });
            }
        };
        
        request.onsuccess = (event) => {
            db = event.target.result;
            loadChats();
        };

        // Chat management
        let currentChatId = null;
        let uploadedFiles = [];
        let currentPreviewFile = null;
        
        // DOM elements
        const chatsList = document.getElementById("chats-list");
        const newChatBtn = document.getElementById("new-chat-btn");
        const sweepAllBtn = document.getElementById("sweep-all-btn");
        const messagesContainer = document.getElementById("messages-container");
        const messageInput = document.getElementById("message-input");
        const sendBtn = document.getElementById("send-btn");
        const chatHeader = document.getElementById("chat-header");
        const fileInput = document.getElementById("file-input");
        const uploadBtn = document.getElementById("upload-btn");
        const uploadedContainer = document.getElementById("uploaded-container");
        const toggleSidebarBtn = document.getElementById("toggle-sidebar");
        const warningModal = document.getElementById("warning-modal");
        const cancelDeleteAllBtn = document.getElementById("cancel-delete-all");
        const confirmDeleteAllBtn = document.getElementById("confirm-delete-all");
        const previewContainer = document.getElementById("preview-container");
        const previewContent = document.getElementById("preview-content");
        const closePreviewBtn = document.getElementById("close-preview-btn");
        const togglePreviewBtn = document.getElementById("toggle-preview");

        // Event Listeners
        newChatBtn.addEventListener("click", createNewChat);
        sendBtn.addEventListener("click", sendMessage);
        messageInput.addEventListener("keydown", handleInputKeydown);
        uploadBtn.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", handleFileUpload);
        toggleSidebarBtn.addEventListener("click", toggleSidebar);
        sweepAllBtn.addEventListener("click", showDeleteAllWarning);
        cancelDeleteAllBtn.addEventListener("click", hideDeleteAllWarning);
        confirmDeleteAllBtn.addEventListener("click", deleteAllChats);
        closePreviewBtn.addEventListener("click", hidePreview);
        togglePreviewBtn.addEventListener("click", togglePreview);
        
        // Generate a placeholder AI welcome message
        function addWelcomeMessage() {
            const welcomeMessage = document.createElement("div");
            welcomeMessage.className = "message ai";
            welcomeMessage.textContent = "Hello! How can I assist you today?";
            messagesContainer.appendChild(welcomeMessage);
        }

        // Handle sidebar toggle for mobile
        function toggleSidebar() {
            const sidebar = document.querySelector('.sidebar');
            sidebar.classList.toggle('show');
        }

        // Toggle document preview panel
        function togglePreview() {
            previewContainer.classList.toggle('hidden');
        }

        // Hide document preview panel
        function hidePreview() {
            previewContainer.classList.add('hidden');
        }

        // Show document preview panel
        function showPreview() {
            previewContainer.classList.remove('hidden');
        }

        // Show warning modal for deleting all chats
        function showDeleteAllWarning() {
            warningModal.classList.add('show');
        }

        // Hide warning modal
        function hideDeleteAllWarning() {
            warningModal.classList.remove('show');
        }

        // Delete all chats
        function deleteAllChats() {
            if (!db) return;
            
            const transaction = db.transaction([chatStoreName], "readwrite");
            const store = transaction.objectStore(chatStoreName);
            const clearRequest = store.clear();
            
            clearRequest.onsuccess = () => {
                // Clear sidebar
                chatsList.innerHTML = "";
                
                // Hide warning modal
                hideDeleteAllWarning();
                
                // Create a new chat
                createNewChat();
            };
            
            clearRequest.onerror = (event) => {
                console.error("Error clearing chats:", event.target.error);
            };
        }

        // Generate initial chat name
        function generateInitialChatName() {
            const date = new Date();
            const formattedDate = date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric'
            });
            
            return `New Chat - ${formattedDate}`;
        }

        // Generate chat name based on conversation content
        function generateChatNameFromContent(messages) {
            if (!messages || messages.length === 0) {
                return generateInitialChatName();
            }
            
            // Find first user message with content
            const firstUserMessage = messages.find(m => m.sender === "user" && m.text.trim().length > 0);
            
            if (!firstUserMessage) {
                return generateInitialChatName();
            }
            
            // Truncate and use first message as title
            let title = firstUserMessage.text.trim();
            
            // Remove common question starters
            title = title.replace(/^(can you|could you|please|help me|how to|how do i|what is|tell me about)/i, '').trim();
            
            // Capitalize first letter
            title = title.charAt(0).toUpperCase() + title.slice(1);
            
            // Truncate to reasonable length
            if (title.length > 30) {
                title = title.substring(0, 27) + '...';
            }
            
            // If title is still empty after processing, use default
            if (title.length === 0) {
                return generateInitialChatName();
            }
            
            return title;
        }

        // Load chats from IndexedDB
        function loadChats() {
            if (!db) return;
            
            const transaction = db.transaction([chatStoreName], "readonly");
            const store = transaction.objectStore(chatStoreName);
            const getAllRequest = store.getAll();
            
            getAllRequest.onsuccess = () => {
                const chats = getAllRequest.result;
                chatsList.innerHTML = "";
                
                if (chats.length === 0) {
                    createNewChat();
                    return;
                }
                
                // Sort chats by creation date (newest first)
                chats.sort((a, b) => b.createdAt - a.createdAt);
                
                chats.forEach(chat => {
                    addChatToSidebar(chat);
                });
                
                // Open the most recent chat
                openChat(chats[0].id);
            };
            
            getAllRequest.onerror = (event) => {
                console.error("Error loading chats:", event.target.error);
                createNewChat();
            };
        }

        // Create a new chat
        function createNewChat() {
            const newChat = {
                id: generateUUID(),
                name: generateInitialChatName(),
                messages: [],
                createdAt: Date.now()
            };
            
            saveChat(newChat, () => {
                addChatToSidebar(newChat);
                openChat(newChat.id);
            });
        }

        // Add chat to sidebar
        function addChatToSidebar(chat) {
            const chatItem = document.createElement("div");
            chatItem.className = "chat-item";
            chatItem.dataset.id = chat.id;
            
            const chatName = document.createElement("div");
            chatName.className = "chat-item-name";
            chatName.textContent = chat.name;
            
            const deleteBtn = document.createElement("button");
            deleteBtn.className = "delete-chat-btn";
            deleteBtn.innerHTML = "×";
            deleteBtn.addEventListener("click", (e) => {
                e.stopPropagation();
                deleteChat(chat.id);
            });
            
            chatItem.appendChild(chatName);
            chatItem.appendChild(deleteBtn);
            
            chatItem.addEventListener("click", () => {
                openChat(chat.id);
            });
            
            chatsList.appendChild(chatItem);
        }

        // Update chat name in sidebar
        function updateChatNameInSidebar(chatId, newName) {
            const chatItem = document.querySelector(`.chat-item[data-id="${chatId}"]`);
            if (chatItem) {
                const chatName = chatItem.querySelector(".chat-item-name");
                if (chatName) {
                    chatName.textContent = newName;
                }
            }
        }

        // Open a chat
        function openChat(chatId) {
            // Remove active class from all chats
            document.querySelectorAll(".chat-item").forEach(item => {
                item.classList.remove("active");
            });
            
            // Add active class to current chat
            const chatItem = document.querySelector(`.chat-item[data-id="${chatId}"]`);
            if (chatItem) {
                chatItem.classList.add("active");
            }
            
            // Clear file uploads for new chat
            uploadedFiles = [];
            uploadedContainer.innerHTML = "";
            
            // Clear preview
            currentPreviewFile = null;
            previewContent.innerHTML = `
                <div class="preview-placeholder">
                    Upload a document or image to see a preview here
                </div>
            `;
            
            // Set current chat ID
            currentChatId = chatId;
            
            // Fetch chat from IndexedDB
            const transaction = db.transaction([chatStoreName], "readonly");
            const store = transaction.objectStore(chatStoreName);
            const getRequest = store.get(chatId);
            
            getRequest.onsuccess = () => {
                const chat = getRequest.result;
                if (!chat) return;
                
                // Update chat header
                chatHeader.textContent = chat.name;
                
                // Clear messages container
                messagesContainer.innerHTML = "";
                
                // Add messages
                if (chat.messages.length === 0) {
                    addWelcomeMessage();
                } else {
                    chat.messages.forEach(message => {
                        addMessageToUI(message.text, message.sender, message.files);
                    });
                }
                
                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            };
            
            getRequest.onerror = (event) => {
                console.error("Error loading chat:", event.target.error);
            };
        }

        // Save chat to IndexedDB
        function saveChat(chat, callback) {
            const transaction = db.transaction([chatStoreName], "readwrite");
            const store = transaction.objectStore(chatStoreName);
            const request = store.put(chat);
            
            request.onsuccess = () => {
                if (callback) callback();
            };
            
            request.onerror = (event) => {
                console.error("Error saving chat:", event.target.error);
            };
        }

        // Delete chat from IndexedDB
        function deleteChat(chatId) {
            if (confirm("Are you sure you want to delete this chat?")) {
                const transaction = db.transaction([chatStoreName], "readwrite");
                const store = transaction.objectStore(chatStoreName);
                const request = store.delete(chatId);
                
                request.onsuccess = () => {
                    // Remove chat from sidebar
                    const chatItem = document.querySelector(`.chat-item[data-id="${chatId}"]`);
                    if (chatItem) {
                        chatItem.remove();
                    }
                    
                    // If current chat is deleted, create a new one or open an existing one
                    if (currentChatId === chatId) {
                        const remainingChat = document.querySelector(".chat-item");
                        if (remainingChat) {
                            openChat(remainingChat.dataset.id);
                        } else {
                            createNewChat();
                        }
                    }
                };
                
                request.onerror = (event) => {
                    console.error("Error deleting chat:", event.target.error);
                };
            }
        }

        // Add message to UI
        function addMessageToUI(text, sender, files = []) {
            const message = document.createElement("div");
            message.className = `message ${sender}`;
            
            // Handle text content
            message.textContent = text;
            
            // Handle file display
            if (files && files.length > 0) {
                const filesContainer = document.createElement("div");
                filesContainer.style.marginTop = "8px";
                
                files.forEach(file => {
                    if (file.type.startsWith("image/")) {
                        const img = document.createElement("img");
                        img.src = file.data;
                        img.className = "file-preview";
                        img.style.maxWidth = "200px";
                        img.style.maxHeight = "200px";
                        img.style.borderRadius = "4px";
                        img.style.marginTop = "8px";
                        img.style.cursor = "pointer";
                        img.addEventListener("click", () => {
                            showFileInPreview(file);
                        });
                        filesContainer.appendChild(img);
                    } else {
                        const fileLink = document.createElement("div");
                        fileLink.className = "uploaded-file";
                        fileLink.style.cursor = "pointer";
                        fileLink.textContent = `📄 ${file.name}`;
                        fileLink.addEventListener("click", () => {
                            showFileInPreview(file);
                        });
                        filesContainer.appendChild(fileLink);
                    }
                });
                
                message.appendChild(filesContainer);
            }
            
            messagesContainer.appendChild(message);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showFileInPreview(file) {
    currentPreviewFile = file;
    previewContent.innerHTML = "";
    
    // Create preview header with tabs
    const previewHeader = document.createElement("div");
    previewHeader.style.display = "flex";
    previewHeader.style.marginBottom = "16px";
    previewHeader.style.borderBottom = "1px solid var(--border-color)";
    
    const fileTab = document.createElement("div");
    fileTab.className = "preview-tab active-tab";
    fileTab.textContent = "File";
    fileTab.style.padding = "8px 16px";
    fileTab.style.cursor = "pointer";
    fileTab.style.borderBottom = "2px solid var(--primary-color)";
    fileTab.addEventListener("click", () => showFileContent(file));
    
    const analysisTab = document.createElement("div");
    analysisTab.className = "preview-tab";
    analysisTab.textContent = "Analysis";
    analysisTab.style.padding = "8px 16px";
    analysisTab.style.cursor = "pointer";
    analysisTab.style.borderBottom = "2px solid transparent";
    analysisTab.addEventListener("click", () => showAnalysisContent(file));
    
    previewHeader.appendChild(fileTab);
    previewHeader.appendChild(analysisTab);
    previewContent.appendChild(previewHeader);
    
    // Content container
    const contentContainer = document.createElement("div");
    contentContainer.id = "preview-content-container";
    previewContent.appendChild(contentContainer);
    
    // Show file content by default
    showFileContent(file);
    
    // Show preview panel
    showPreview();
}

// Show file content in preview
function showFileContent(file) {
    // Update tabs
    document.querySelectorAll(".preview-tab").forEach(tab => {
        tab.style.borderBottom = "2px solid transparent";
    });
    document.querySelector(".preview-tab:first-child").style.borderBottom = "2px solid var(--primary-color)";
    
    const contentContainer = document.getElementById("preview-content-container");
    contentContainer.innerHTML = "";
    
    if (file.type.startsWith("image/")) {
        const img = document.createElement("img");
        img.src = file.data;
        img.className = "preview-image";
        contentContainer.appendChild(img);
    } else if (file.type === "application/pdf") {
        const embed = document.createElement("embed");
        embed.src = file.data;
        embed.className = "document-preview";
        embed.type = "application/pdf";
        contentContainer.appendChild(embed);
    } else {
        // For other document types, show a basic preview with file name
        const docPlaceholder = document.createElement("div");
        docPlaceholder.style.textAlign = "center";
        
        const docIcon = document.createElement("div");
        docIcon.style.fontSize = "48px";
        docIcon.style.marginBottom = "16px";
        docIcon.textContent = "📄";
        
        const docName = document.createElement("div");
        docName.style.fontWeight = "500";
        docName.textContent = file.name;
        
        const docInfo = document.createElement("div");
        docInfo.style.color = "var(--text-secondary)";
        docInfo.style.marginTop = "8px";
        docInfo.textContent = "Preview not available for this file type";
        
        docPlaceholder.appendChild(docIcon);
        docPlaceholder.appendChild(docName);
        docPlaceholder.appendChild(docInfo);
        
        contentContainer.appendChild(docPlaceholder);
    }
}

// Show analysis content in preview
function showAnalysisContent(file) {
    // Update tabs
    document.querySelectorAll(".preview-tab").forEach(tab => {
        tab.style.borderBottom = "2px solid transparent";
    });
    document.querySelector(".preview-tab:nth-child(2)").style.borderBottom = "2px solid var(--primary-color)";
    
    const contentContainer = document.getElementById("preview-content-container");
    contentContainer.innerHTML = "";
    
    if (!file.analysis) {
        const analysisPlaceholder = document.createElement("div");
        analysisPlaceholder.style.textAlign = "center";
        analysisPlaceholder.style.padding = "20px";
        
        const analysisIcon = document.createElement("div");
        analysisIcon.style.fontSize = "48px";
        analysisIcon.style.marginBottom = "16px";
        analysisIcon.textContent = "🔍";
        
        const analysisInfo = document.createElement("div");
        analysisInfo.style.color = "var(--text-secondary)";
        analysisInfo.textContent = "Analysis not available for this file";
        
        analysisPlaceholder.appendChild(analysisIcon);
        analysisPlaceholder.appendChild(analysisInfo);
        
        contentContainer.appendChild(analysisPlaceholder);
    } else {
        const analysisContent = document.createElement("div");
        analysisContent.style.padding = "16px";
        analysisContent.style.lineHeight = "1.6";
        analysisContent.style.overflowY = "auto";
        analysisContent.style.maxHeight = "calc(100vh - 200px)";
        
        // Format the analysis with markdown-like parsing
        let formattedContent = file.analysis
            .replace(/\n\n/g, '<br><br>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/^# (.*?)$/gm, '<h2>$1</h2>')
            .replace(/^## (.*?)$/gm, '<h3>$1</h3>')
            .replace(/^### (.*?)$/gm, '<h4>$1</h4>');
        
        analysisContent.innerHTML = formattedContent;
        
        contentContainer.appendChild(analysisContent);
    }
}

        // Send a message
async function sendMessage() {
    const text = messageInput.value.trim();
    if (text === "" && uploadedFiles.length === 0) return;
    
    // Add user message to UI
    addMessageToUI(text, "user", uploadedFiles);
    
    try {
        // Create a Promise wrapper for IndexedDB transaction
        const chat = await new Promise((resolve, reject) => {
            const transaction = db.transaction([chatStoreName], "readwrite");
            const store = transaction.objectStore(chatStoreName);
            const getRequest = store.get(currentChatId);
            
            getRequest.onsuccess = () => {
                resolve(getRequest.result);
            };
            
            getRequest.onerror = (event) => {
                console.error("Error getting chat:", event.target.error);
                reject(event.target.error);
            };
        });
        
        // Add message to chat
        chat.messages.push({
            text: text,
            sender: "user",
            timestamp: Date.now(),
            files: uploadedFiles
        });
        
        // Update chat name based on conversation if it's still the default
        if (chat.name.startsWith("New Chat")) {
            const newName = generateChatNameFromContent(chat.messages);
            chat.name = newName;
            
            // Update chat header
            chatHeader.textContent = newName;
            
            // Update sidebar
            updateChatNameInSidebar(chat.id, newName);
        }
        
        // Prepare files for next step
        const filesToSave = [...uploadedFiles];
        
        // Clear input and files
        messageInput.value = "";
        uploadedFiles = [];
        uploadedContainer.innerHTML = "";
        
        // Reset textarea height
        messageInput.style.height = "auto";
        
        // Get AI response
        const chatMessages = [];
        
        // Add system message
        chatMessages.push({
            role: "system",
            content: "You are a helpful AI assistant. Be concise and informative."
        });
        
        // Add previous messages for context (limit to last 10 for performance)
        const lastMessages = chat.messages.slice(-10);
        lastMessages.forEach(msg => {
            chatMessages.push({
                role: msg.sender === "user" ? "user" : "assistant",
                content: msg.text
            });
        });
        
        // If there are uploaded files in this message, mention them to the AI
        if (filesToSave.length > 0) {
            const fileInfo = filesToSave.map(file => {
                let info = `File name: ${file.name}, Type: ${file.type}`;
                if (file.analysis) {
                    info += `, Analysis: ${file.analysis.substring(0, 200)}...`;
                }
                return info;
            }).join("\n\n");
            
            chatMessages[chatMessages.length - 1].content += `\n\nI've uploaded these files:\n${fileInfo}`;
        }
        
        // Show typing indicator
        const typingIndicator = document.createElement("div");
        typingIndicator.className = "message ai typing-indicator";
        typingIndicator.textContent = "Thinking...";
        messagesContainer.appendChild(typingIndicator);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // Get AI response
        const aiResponse = await callOpenAI(chatMessages);
        
        // Remove typing indicator
        typingIndicator.remove();
        
        // Add AI response to UI
        addMessageToUI(aiResponse, "ai");
        
        // Add AI response to chat
        chat.messages.push({
            text: aiResponse,
            sender: "ai",
            timestamp: Date.now()
        });
        
        // Save chat
        await new Promise((resolve, reject) => {
            const saveTransaction = db.transaction([chatStoreName], "readwrite");
            const saveStore = saveTransaction.objectStore(chatStoreName);
            const saveRequest = saveStore.put(chat);
            
            saveRequest.onsuccess = () => {
                resolve();
            };
            
            saveRequest.onerror = (event) => {
                console.error("Error saving chat:", event.target.error);
                reject(event.target.error);
            };
        });
    } catch (error) {
        console.error("Error in send message flow:", error);
        addMessageToUI("Sorry, there was an error processing your message.", "ai");
    }
}

        // Handle keyboard input
        function handleInputKeydown(e) {
            if (e.key === "Enter" && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
            
            // Auto-resize textarea
            setTimeout(() => {
                messageInput.style.height = "auto";
                messageInput.style.height = (messageInput.scrollHeight) + "px";
            }, 0);
        }

        // Handle file upload
        function handleFileUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            
            [...files].forEach((file, index) => {
                const reader = new FileReader();
                
                reader.onload = async (event) => {
    const fileData = {
        name: file.name,
        type: file.type,
        data: event.target.result
    };
    
    // Add loading state to the UI
    const filePreview = document.createElement("div");
    filePreview.className = "uploaded-file";
    filePreview.id = `file-${uploadedFiles.length}`;
    
    // Create file preview or icon
    if (file.type.startsWith("image/")) {
        const img = document.createElement("img");
        img.src = event.target.result;
        img.className = "file-preview";
        filePreview.appendChild(img);
    }
    
    const fileName = document.createElement("div");
    fileName.className = "file-name";
    fileName.textContent = file.name;
    filePreview.appendChild(fileName);
    
    const statusText = document.createElement("div");
    statusText.className = "file-name";
    statusText.textContent = "Analyzing...";
    statusText.style.color = "var(--text-secondary)";
    statusText.style.fontStyle = "italic";
    filePreview.appendChild(statusText);
    
    uploadedContainer.appendChild(filePreview);
    
    // Analyze the document (this will take some time)
    fileData.analysis = await analyzeDocument(fileData);
    
    // Update UI after analysis
    statusText.textContent = "Analysis complete";
    statusText.style.fontStyle = "normal";
    statusText.style.color = "var(--primary-color)";
    
    // Add file to the list
    uploadedFiles.push(fileData);
    
    // Update the preview with remove button now that analysis is complete
    const removeBtn = document.createElement("button");
    removeBtn.className = "remove-file-btn";
    removeBtn.innerHTML = "×";
    removeBtn.dataset.index = uploadedFiles.length - 1;
    removeBtn.addEventListener("click", removeFile);
    filePreview.appendChild(removeBtn);
    
    // If this is the first file uploaded, show it in the preview
    if (index === 0) {
        showFileInPreview(fileData);
    }
};
                
                if (file.type.startsWith("image/")) {
                    reader.readAsDataURL(file);
                } else {
                    reader.readAsDataURL(file); // For non-image files, we still use DataURL for simplicity
                }
            });
            
            // Clear file input
            fileInput.value = "";
        }

        // Remove uploaded file
        function removeFile(e) {
            const index = parseInt(e.target.dataset.index);
            
            // If this is the currently previewed file, clear the preview
            if (currentPreviewFile === uploadedFiles[index]) {
                currentPreviewFile = null;
                previewContent.innerHTML = `
                    <div class="preview-placeholder">
                        Upload a document or image to see a preview here
                    </div>
                `;
            }
            
            uploadedFiles.splice(index, 1);
            
            // Rebuild file previews
            uploadedContainer.innerHTML = "";
            uploadedFiles.forEach((file, i) => {
                const filePreview = document.createElement("div");
                filePreview.className = "uploaded-file";
                
                if (file.type.startsWith("image/")) {
                    const img = document.createElement("img");
                    img.src = file.data;
                    img.className = "file-preview";
                    filePreview.appendChild(img);
                }
                
                const fileName = document.createElement("div");
                fileName.className = "file-name";
                fileName.textContent = file.name;
                filePreview.appendChild(fileName);
                
                const removeBtn = document.createElement("button");
                removeBtn.className = "remove-file-btn";
                removeBtn.innerHTML = "×";
                removeBtn.dataset.index = i;
                removeBtn.addEventListener("click", removeFile);
                filePreview.appendChild(removeBtn);
                
                uploadedContainer.appendChild(filePreview);
            });
            
            // If no files left, hide preview panel on mobile
            if (uploadedFiles.length === 0 && window.innerWidth <= 992) {
                hidePreview();
            }
        }

// Call OpenAI API
async function callOpenAI(messages, options = {}) {
    try {
        const response = await fetch(OPENAI_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${OPENAI_API_KEY}`
            },
            body: JSON.stringify({
                model: options.model || OPENAI_MODEL,
                messages: messages,
                max_tokens: options.max_tokens || 1000,
                temperature: options.temperature || 0.7
            })
        });

        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error?.message || 'API request failed');
        }

        const data = await response.json();
        return data.choices[0].message.content;
    } catch (error) {
        console.error("Error calling OpenAI API:", error);
        return "Sorry, I encountered an error while processing your request.";
    }
}

// Advanced PDF text extraction function
async function extractTextFromPDF(arrayBuffer) {
    try {
        // Convert ArrayBuffer to byte array
        const bytes = new Uint8Array(arrayBuffer);
        
        // Check if this is a PDF
        const header = bytesToString(bytes.slice(0, 8));
        if (!header.startsWith("%PDF-")) {
            return "Not a valid PDF file";
        }
        
        // Initialize result container for multiple extraction methods
        const extractionResults = [];
        let bestResult = "";
        
        // EXTRACTION METHOD 1: Direct content stream scanning
        // Look for text objects between BT and ET markers
        let directExtraction = "";
        
        // Find all occurrences of "BT" (Begin Text) markers
        const btPositions = findPatternPositions(bytes, [66, 84, 32]); // "BT "
        const etPositions = findPatternPositions(bytes, [32, 69, 84]); // " ET"
        
        for (let i = 0; i < btPositions.length; i++) {
            const btPos = btPositions[i];
            
            // Find the next ET after this BT
            const nextET = etPositions.find(pos => pos > btPos);
            if (!nextET) continue;
            
            // Get the text block
            const textBlock = bytes.slice(btPos, nextET + 3);
            const blockText = extractTextFromOperators(textBlock);
            if (blockText.trim()) {
                directExtraction += blockText + " ";
            }
        }
        
        extractionResults.push({
            method: "Direct Text Blocks",
            text: directExtraction,
            score: scoreExtractedText(directExtraction)
        });
        
        // EXTRACTION METHOD 2: Stream content extraction
        let streamExtraction = "";
        
        // Find all "stream" and "endstream" markers
        const streamStarts = findPatternPositions(bytes, stringToBytes("stream"));
        const streamEnds = findPatternPositions(bytes, stringToBytes("endstream"));
        
        if (streamStarts.length > 0 && streamEnds.length > 0) {
            for (let i = 0; i < streamStarts.length; i++) {
                const startPos = streamStarts[i] + 6; // "stream" length
                
                // Find corresponding endstream
                const endPos = streamEnds.find(pos => pos > startPos);
                if (!endPos) continue;
                
                // Check if there's a newline after "stream"
                let contentStart = startPos;
                if (bytes[startPos] === 13 && bytes[startPos + 1] === 10) { // CR LF
                    contentStart += 2;
                } else if (bytes[startPos] === 10) { // LF
                    contentStart += 1;
                }
                
                // Get stream content
                const streamContent = bytes.slice(contentStart, endPos);
                
                // Check if it might be a content stream by looking for text operators
                if (hasTextOperators(streamContent)) {
                    const streamText = extractTextFromOperators(streamContent);
                    if (streamText.trim()) {
                        streamExtraction += streamText + " ";
                    }
                }
            }
        }
        
        extractionResults.push({
            method: "Stream Content",
            text: streamExtraction,
            score: scoreExtractedText(streamExtraction)
        });
        
        // EXTRACTION METHOD 3: String literal scanning
        let stringLiteralExtraction = "";
        
        // Scan for string literals in parentheses - common in PDF content
        let inString = false;
        let nestedParens = 0;
        let currentString = "";
        
        for (let i = 0; i < bytes.length; i++) {
            const byte = bytes[i];
            
            if (!inString && byte === 40) { // '(' starts a string
                inString = true;
                nestedParens = 0;
                currentString = "";
            } else if (inString) {
                if (byte === 40 && bytes[i-1] !== 92) { // '(' not escaped
                    nestedParens++;
                    currentString += String.fromCharCode(byte);
                } else if (byte === 41 && bytes[i-1] !== 92) { // ')' not escaped
                    if (nestedParens > 0) {
                        nestedParens--;
                        currentString += String.fromCharCode(byte);
                    } else {
                        inString = false;
                        // Check if this looks like meaningful text
                        if (currentString.length > 1 && /[a-zA-Z0-9]/.test(currentString)) {
                            // If next byte is Tj or TJ, it's definitely text
                            const nextBytes = bytes.slice(i+1, i+4);
                            const nextStr = bytesToString(nextBytes);
                            if (nextStr.includes("Tj") || nextStr.includes("TJ")) {
                                stringLiteralExtraction += currentString + " ";
                            } 
                            // Otherwise, use heuristics to guess if it's text
                            else if (currentString.length > 3 && /[a-zA-Z]{2,}/.test(currentString)) {
                                stringLiteralExtraction += currentString + " ";
                            }
                        }
                    }
                } else if (byte === 92) { // '\' escape character
                    // Skip the escape and add the next character directly
                    if (i < bytes.length - 1) {
                        i++;
                        // Handle common PDF escape sequences
                        if (bytes[i] === 110) { // \n
                            currentString += '\n';
                        } else if (bytes[i] === 114) { // \r
                            currentString += '\r';
                        } else if (bytes[i] === 116) { // \t
                            currentString += '\t';
                        } else if (bytes[i] === 98) { // \b
                            currentString += '\b';
                        } else if (bytes[i] === 102) { // \f
                            currentString += '\f';
                        } else if (bytes[i] === 40) { // \(
                            currentString += '(';
                        } else if (bytes[i] === 41) { // \)
                            currentString += ')';
                        } else if (bytes[i] === 92) { // \\
                            currentString += '\\';
                        } else {
                            // Handle octal escapes like \123
                            if (bytes[i] >= 48 && bytes[i] <= 55) { // '0'-'7'
                                const octal = [bytes[i]];
                                if (i < bytes.length - 2 && bytes[i+1] >= 48 && bytes[i+1] <= 55) {
                                    octal.push(bytes[i+1]);
                                    i++;
                                    if (i < bytes.length - 2 && bytes[i+1] >= 48 && bytes[i+1] <= 55) {
                                        octal.push(bytes[i+1]);
                                        i++;
                                    }
                                }
                                const charCode = parseInt(bytesToString(octal), 8);
                                currentString += String.fromCharCode(charCode);
                            } else {
                                currentString += String.fromCharCode(bytes[i]);
                            }
                        }
                    }
                } else {
                    currentString += String.fromCharCode(byte);
                }
            }
        }
        
        extractionResults.push({
            method: "String Literals",
            text: stringLiteralExtraction,
            score: scoreExtractedText(stringLiteralExtraction)
        });
        
        // EXTRACTION METHOD 4: ASCII Text Mining
        // Extract any sequence that looks like words
        let asciiExtraction = "";
        let currentWord = "";
        let wordCount = 0;
        
        for (let i = 0; i < bytes.length; i++) {
            const byte = bytes[i];
            
            // Only consider printable ASCII characters
            if (byte >= 32 && byte <= 126) {
                const char = String.fromCharCode(byte);
                
                // If it's a letter or number, add to current word
                if (/[a-zA-Z0-9]/.test(char)) {
                    currentWord += char;
                } 
                // Otherwise, check if we have a complete word
                else if (currentWord.length > 0) {
                    // Only add words that look like real words (at least 2 chars)
                    if (currentWord.length >= 2) {
                        asciiExtraction += currentWord + " ";
                        wordCount++;
                    }
                    currentWord = "";
                }
            } 
            // End of word
            else if (currentWord.length > 0) {
                if (currentWord.length >= 2) {
                    asciiExtraction += currentWord + " ";
                    wordCount++;
                }
                currentWord = "";
                
                // Add paragraph breaks for readability
                if (byte === 10 || byte === 13) {
                    asciiExtraction += "\n";
                }
            }
        }
        
        extractionResults.push({
            method: "ASCII Mining",
            text: asciiExtraction,
            score: scoreExtractedText(asciiExtraction)
        });
        
        // Find the best extraction method based on scoring
        extractionResults.sort((a, b) => b.score - a.score);
        
        if (extractionResults.length > 0 && extractionResults[0].score > 0) {
            bestResult = extractionResults[0].text;
            
            // Combine results if they seem complementary
            if (extractionResults.length > 1 && 
                extractionResults[1].score > extractionResults[0].score * 0.7 &&
                !extractionResults[0].text.includes(extractionResults[1].text)) {
                bestResult = combineExtractions(extractionResults[0].text, extractionResults[1].text);
            }
        }
        
        // Clean up the result
        bestResult = cleanExtractedText(bestResult);
        
        if (bestResult.trim().length < 50) {
            // Try one last approach - direct ASCII extraction without filtering
            const fullText = bytesToString(bytes);
            const textOnlyChars = fullText.replace(/[^\x20-\x7E\n\r\t]/g, '');
            const cleanedText = textOnlyChars.replace(/[\x00-\x1F\x7F-\xFF]/g, '');
            
            if (cleanedText.trim().length > bestResult.trim().length) {
                bestResult = cleanedText;
            }
        }
        
        // For debugging purposes, log the results of all extraction methods
        console.log("PDF Extraction Results:", {
            bestMethod: extractionResults[0]?.method || "None",
            bestScore: extractionResults[0]?.score || 0,
            textLength: bestResult.length,
            allMethods: extractionResults.map(r => ({ 
                method: r.method, 
                score: r.score, 
                length: r.text.length
            }))
        });
        
        return bestResult.trim().length > 0 ? bestResult : "Could not extract text from this PDF.";
    } catch (error) {
        console.error("Error extracting text from PDF:", error);
        return "Error extracting text from PDF: " + error.message;
    }
}

// Score the quality of extracted text to determine best method
function scoreExtractedText(text) {
    if (!text) return 0;
    
    let score = 0;
    
    // More words = higher score
    const words = text.split(/\s+/).filter(w => w.length > 0);
    score += words.length * 10;
    
    // More variety of words = higher score
    const uniqueWords = new Set(words.map(w => w.toLowerCase()));
    score += uniqueWords.size * 5;
    
    // Higher percentage of dictionary words = higher score
    const dictionaryWordCount = words.filter(word => 
        /^[a-zA-Z]{2,}$/.test(word) && !commonPdfNonWords.includes(word.toLowerCase())
    ).length;
    
    score += (dictionaryWordCount / Math.max(1, words.length)) * 1000;
    
    // Text with punctuation is more likely to be real content
    const punctuation = (text.match(/[,.;:!?]/g) || []).length;
    score += punctuation * 2;
    
    // Text with capitalized words is more likely to be content
    const capitalizedWords = words.filter(w => w.length > 0 && w[0].toUpperCase() === w[0]).length;
    score += capitalizedWords * 3;
    
    // Common phrases in documents increase score
    const commonPhrases = [
        "the", "and", "for", "that", "this", "with", "from", "have", "not",
        "experience", "skills", "education", "work", "professional", "project",
        "resume", "summary", "about", "contact", "reference"
    ];
    
    for (const phrase of commonPhrases) {
        const regex = new RegExp(`\\b${phrase}\\b`, 'gi');
        const matches = (text.match(regex) || []).length;
        score += matches * 5;
    }
    
    return score;
}

// Common PDF non-words to filter out
const commonPdfNonWords = [
    "obj", "endobj", "eofc", "xref", "startxref", "pdf", "et", "bt", 
    "tm", "td", "tf", "tj", "xobj", "endobj", "rgb", "cmyk"
];

// Extract text from PDF text operators
function extractTextFromOperators(bytes) {
    let text = "";
    const byteStr = bytesToString(bytes);
    
    // Extract text from "Tj" operations
    const tjRegex = /\((.*?)\)\s*Tj/g;
    let match;
    while ((match = tjRegex.exec(byteStr)) !== null) {
        text += match[1] + " ";
    }
    
    // Extract text from "TJ" array operations
    const tjArrayRegex = /\[(.*?)\]\s*TJ/g;
    while ((match = tjArrayRegex.exec(byteStr)) !== null) {
        const arrayContent = match[1];
        const stringLiterals = arrayContent.match(/\(.*?\)/g) || [];
        
        for (const literal of stringLiterals) {
            // Remove outer parentheses
            text += literal.substring(1, literal.length - 1) + " ";
        }
    }
    
    return text;
}

// Check if a byte array likely contains text operators
function hasTextOperators(bytes) {
    const operators = ["BT", "ET", "Tj", "TJ", "Tm", "Td", "Tf"];
    const byteStr = bytesToString(bytes);
    
    for (const op of operators) {
        if (byteStr.includes(op)) {
            return true;
        }
    }
    
    return false;
}

// Find all positions of a pattern in a byte array
function findPatternPositions(haystack, needle) {
    const positions = [];
    
    for (let i = 0; i <= haystack.length - needle.length; i++) {
        let found = true;
        
        for (let j = 0; j < needle.length; j++) {
            if (haystack[i + j] !== needle[j]) {
                found = false;
                break;
            }
        }
        
        if (found) {
            positions.push(i);
        }
    }
    
    return positions;
}

// Convert string to byte array
function stringToBytes(str) {
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i) & 0xff;
    }
    return bytes;
}

// Convert byte array to string
function bytesToString(bytes) {
    let result = "";
    for (let i = 0; i < bytes.length; i++) {
        result += String.fromCharCode(bytes[i]);
    }
    return result;
}

// Clean up extracted text
function cleanExtractedText(text) {
    return text
        .replace(/(\r\n|\r|\n){2,}/g, '\n\n') // Normalize multiple line breaks
        .replace(/\s+/g, ' ')                 // Normalize whitespace
        .replace(/\( /g, '(')                 // Fix spacing in parentheses
        .replace(/ \)/g, ')')
        .replace(/\\n/g, '\n')                // Convert escaped newlines
        .replace(/\\r/g, '')                  // Remove escaped carriage returns
        .replace(/\\t/g, ' ')                 // Convert escaped tabs to spaces
        .replace(/\\\(/g, '(')                // Unescape parentheses
        .replace(/\\\)/g, ')')
        .replace(/\s+/g, ' ')                 // Normalize whitespace again
        .replace(/\(\s*\)/g, '')              // Remove empty parentheses
        .replace(/\s+\.+/g, '.')              // Fix spacing around punctuation
        .replace(/\s+,+/g, ',')
        .replace(/\s+;+/g, ';')
        .replace(/\s+:+/g, ':')
        .replace(/\s+!+/g, '!')
        .replace(/\s+\?+/g, '?')
        .trim();
}

// Combine multiple extraction results, removing duplicates
function combineExtractions(text1, text2) {
    // Split into sentences or fragments
    const fragments1 = text1.split(/(?<=[.!?])\s+/);
    const fragments2 = text2.split(/(?<=[.!?])\s+/);
    
    // Create a map for quick duplicate checking
    const fragmentMap = new Map();
    
    // Add all fragments from text1
    for (const fragment of fragments1) {
        const key = fragment.toLowerCase().trim();
        if (key.length > 0) {
            fragmentMap.set(key, fragment);
        }
    }
    
    // Add non-duplicate fragments from text2
    for (const fragment of fragments2) {
        const key = fragment.toLowerCase().trim();
        if (key.length > 0 && !fragmentMap.has(key)) {
            fragmentMap.set(key, fragment);
        }
    }
    
    // Combine all unique fragments
    return Array.from(fragmentMap.values()).join(' ');
}

// The complete analyzeDocument function with all supporting functions
async function analyzeDocument(fileData) {
    try {
        let textContent = "";
        let documentType = "UNKNOWN";
        let extractionSuccess = true;
        
        // Process based on file type
        if (fileData.type.startsWith("image/")) {
            return "This is an image file. Analysis based on image content is not available in this demo.";
        } else if (fileData.type === "application/pdf") {
            // Use our ultra-simplified PDF text extraction
            if (!fileData.textContent) {
                // If text wasn't extracted during upload, do it now
                if (fileData.rawBuffer) {
                    textContent = await extractTextFromPDF(fileData.rawBuffer);
                } else if (fileData.data) {
                    // Try to get the array buffer from the data URL
                    try {
                        const response = await fetch(fileData.data);
                        const buffer = await response.arrayBuffer();
                        textContent = await extractTextFromPDF(buffer);
                    } catch (e) {
                        console.error("Error fetching PDF data:", e);
                        textContent = "Could not access PDF content for analysis.";
                        extractionSuccess = false;
                    }
                }
            } else {
                textContent = fileData.textContent;
            }
            
            // Critical quality validation - check if we have meaningful text
            if (!textContent || 
                textContent.length < 100 || 
                textContent.includes("Could not extract") ||
                !validateExtractedText(textContent)) {
                console.log("PDF Text Extraction Failed or Low Quality - Content length:", textContent?.length || 0);
                return "Limited text was extracted from this PDF. It may be a scanned document or contain mostly images.";
            }
        } else {
            // For other text-based files, use the content directly
            textContent = fileData.textContent || fileData.data;
            
            if (textContent.startsWith("data:")) {
                try {
                    const base64Content = textContent.split(',')[1];
                    textContent = atob(base64Content);
                } catch (e) {
                    // It's not a base64-encoded string, use as is
                }
            }
        }

        // If extraction failed with explicit error message
        if (!extractionSuccess || textContent.includes("Error extracting text")) {
            return "Unable to extract meaningful text from this document. It may be password-protected, scanned, or contain primarily non-text elements.";
        }

        // Log successfully extracted text length for debugging
        console.log("Document text extraction successful -", textContent.length, "characters");
        
        // Sample the text for analysis
        const textSample = textContent.substring(0, 1000);
        
        // Basic document type classification
        documentType = await classifyDocument(textSample);
        
        // Define analysis prompt based on document type
        const analysisPrompt = getAnalysisPrompt(documentType);
        
        // Prepare user message with document content
        const userMessage = {
            role: "user",
            content: `Document to analyze (${documentType} format): ${textContent.substring(0, 5000)}

IMPORTANT: Your analysis must be metrics-driven with specific values where possible. If the text doesn't appear to make sense or seems like extraction errors, acknowledge this explicitly rather than trying to analyze corrupted text.`
        };

        // Log analytics request data for debugging
        console.log("Document analysis request:", {
            documentType,
            textLength: textContent.length
        });

        // Call the API for analysis
        const analysis = await callOpenAI([analysisPrompt, userMessage], {
            max_tokens: 1000,
            temperature: 0.2
        });
        
        return analysis;
    } catch (error) {
        console.error("Error analyzing document:", error);
        return "Unable to analyze this document due to processing limitations: " + error.message;
    }
}

// Validate if extracted text seems like real content
function validateExtractedText(text) {
    if (!text || text.length < 100) return false;
    
    // Check for common words that should appear in normal text
    const commonWords = ['the', 'and', 'for', 'this', 'that', 'with'];
    let commonWordCount = 0;
    
    for (const word of commonWords) {
        const regex = new RegExp(`\\b${word}\\b`, 'gi');
        const matches = (text.match(regex) || []).length;
        commonWordCount += matches;
    }
    
    // Check sentence structure
    const sentences = text.match(/[A-Z][^.!?]*[.!?]/g) || [];
    
    // If we have common words and some sentence structure, text is probably valid
    return commonWordCount >= 3 && sentences.length >= 2;
}

// Simple document classification
async function classifyDocument(textSample) {
    // Basic classification based on content patterns
    if (/experience|education|skills|work history|employment|resume|cv/gi.test(textSample)) {
        return "RESUME";
    } else if (/revenue|expense|profit|loss|balance|assets|liabilities|cash flow/gi.test(textSample)) {
        return "FINANCIAL";
    } else if (/respondent|satisfaction|rating|score|question|response rate/gi.test(textSample)) {
        return "SURVEY";
    } else if (/conclusion|recommendation|executive summary|findings|analysis/gi.test(textSample)) {
        return "REPORT";
    }
    
    return "DOCUMENT";
}

// Get appropriate analysis prompt based on document type
function getAnalysisPrompt(documentType) {
    // Base prompt for all document types
    const basePrompt = {
        role: "system",
        content: `You are a data-focused document analyst providing quantitative document analysis. Focus on measurable content metrics, comparative standards, and data integrity.

IMPORTANT: If the document text appears to be corrupted, contains PDF syntax, or doesn't make logical sense as a ${documentType}, explicitly state this first before attempting any analysis. Do not try to analyze text that appears to be extraction errors or PDF syntax.

Format your analysis in a clear, structured way with headings and bullet points.`
    };
    
    // Document-specific prompts
    const prompts = {
        "RESUME": {
            role: "system",
            content: `You are a specialized HR analytics expert conducting resume analysis. Focus on quantifiable metrics, industry benchmarks, and career progression patterns.

IMPORTANT: If the resume text appears to be corrupted, contains extraction errors, or doesn't read like a proper resume, explicitly state this first before attempting any analysis. DO NOT analyze text that appears to be PDF syntax or garbage data.

Format your analysis as follows:

# Resume Analytics Report

## Qualification Metrics
- Skills alignment score: [percentage match to industry requirements or "Unable to determine" if unclear]
- Experience density: [years per role vs. industry average or "Unable to determine" if unclear]
- Education relevance rating: [numerical assessment with justification or "Unable to determine" if unclear]

## Comparative Benchmark Analysis
- Career progression compared to industry standard timeframes
- Skill set completeness vs. role requirements (percentage)
- Achievement metrics against comparable professionals

## Content Effectiveness Assessment
- Quantifiable achievement inclusion rate: [percentage of roles with metrics]
- Keyword optimization score for ATS systems
- Professional language consistency rating

## Opportunity Indicators
- Skill gap analysis with percentage improvement potential
- Career trajectory projection based on industry patterns
- Competitive positioning in current job market (percentile estimate)

## Enhancement Recommendations
- 3-4 specific improvements with projected impact on interview success rate
- Priority ranking of missing qualifications (High/Medium/Low)
- Suggested metrics to emphasize based on industry trends`
        },
        
        "FINANCIAL": {
            role: "system",
            content: `You are a financial analyst providing quantitative financial document analysis. Focus on financial metrics, industry benchmarks, and risk indicators.

IMPORTANT: If the financial document text appears to be corrupted, contains extraction errors, or doesn't read like a proper financial document, explicitly state this first before attempting any analysis. DO NOT analyze text that appears to be PDF syntax or garbage data.

Format your analysis as follows:

# Financial Analysis Report

## Key Financial Indicators
- Profitability metrics: [ROI, margins, etc. with comparative values]
- Liquidity assessment: [ratios with industry benchmarks]
- Growth metrics: [YoY changes with statistical significance]

## Benchmark Comparison
- Industry-standard ratios vs. document values
- Percentile ranking of key metrics against sector averages
- Deviation analysis from forecasted values

## Risk Assessment
- Financial stability indicators with confidence intervals
- Exposure metrics compared to industry tolerance levels
- Cash flow sustainability rating with supporting data

## Data Integrity Issues
- Flag potential accounting irregularities
- Identify numerical inconsistencies
- Note missing critical financial disclosures

## Strategic Recommendations
- 3-4 data-backed financial strategies with projected impact
- Risk mitigation priorities ranked by potential value
- Performance improvement metrics with target values`
        },
        
        "SURVEY": {
            role: "system",
            content: `You are a survey data analyst providing statistical survey analysis. Focus on response patterns, confidence intervals, and comparative benchmarks.

IMPORTANT: If the survey document text appears to be corrupted, contains extraction errors, or doesn't read like a proper survey, explicitly state this first before attempting any analysis. DO NOT analyze text that appears to be PDF syntax or garbage data.

Format your analysis as follows:

# Survey Analytics Report

## Statistical Overview
- Response distribution analysis with confidence intervals
- Satisfaction/rating score breakdowns with percentile rankings
- Correlation patterns between response categories

## Benchmark Comparison
- Response metrics vs. industry averages
- Sentiment comparison against similar surveys
- Deviation analysis from expected response patterns

## Statistical Validity Assessment
- Sample size adequacy evaluation
- Response bias indicators
- Confidence level calculations for key findings

## Anomaly Detection
- Outlier responses with statistical significance
- Unexpected correlation patterns between questions
- Response inconsistencies and potential data quality issues

## Action Recommendations
- 3-4 data-driven recommendations based on statistically significant findings
- Prioritized opportunities ranked by potential impact
- Suggested follow-up metrics with target improvement values`
        },
        
        "REPORT": {
            role: "system",
            content: `You are a data-focused analyst providing quantitative report analysis. Focus on measurable content metrics, comparative standards, and data integrity.

IMPORTANT: If the report text appears to be corrupted, contains extraction errors, or doesn't read like a proper report, explicitly state this first before attempting any analysis. DO NOT analyze text that appears to be PDF syntax or garbage data.

Format your analysis as follows:

# Report Analytics Review

## Content Structure Assessment
- Information density metrics: [content/length ratios vs standards]
- Organizational clarity score with benchmark comparison
- Key information completeness rating (percentage)

## Key Findings Evaluation
- Statistical significance of presented data
- Evidence strength ranking for major conclusions
- Comparative analysis with industry standards

## Methodology Assessment
- Research validity score based on described methods
- Sample size adequacy evaluation
- Confidence intervals for key findings (if applicable)

## Impact Potential
- Actionability score for recommendations
- Implementation feasibility rating with justification
- Projected ROI or impact metrics for key suggestions

## Enhancement Recommendations
- 3-4 specific improvements with projected impact percentages
- Priority matrix of missing elements (High/Medium/Low)
- Performance indicators to monitor after implementing changes`
        },
        
        "DOCUMENT": {
            role: "system",
            content: `You are a data-focused document analyst providing quantitative document analysis. Focus on measurable content metrics, comparative standards, and data integrity.

IMPORTANT: If the document text appears to be corrupted, contains extraction errors, or doesn't make logical sense, explicitly state this first before attempting any analysis. DO NOT analyze text that appears to be PDF syntax or garbage data.

Format your analysis as follows:

# Document Analytics Report

## Content Structure Assessment
- Information density metrics: [content/length ratios vs standards]
- Organizational clarity score with benchmark comparison
- Key information completeness rating (percentage)

## Comparative Analysis
- Document structure vs. industry standard templates
- Information hierarchy alignment with best practices
- Key content inclusion rate compared to similar documents

## Data Integrity Review
- Identification of incomplete information sections
- Inconsistency detection with specific examples
- Missing critical components based on document type

## Effectiveness Metrics
- Purpose fulfillment score with justification
- Impact potential rating based on content analysis
- Readability metrics with comparative benchmarks

## Enhancement Recommendations
- 3-4 specific improvements with projected impact percentages
- Priority matrix of missing elements (High/Medium/Low)
- Performance indicators to monitor after implementing changes`
        }
    };
    
    // Return specific prompt if available, otherwise use base prompt
    return prompts[documentType] || basePrompt;
}

// OpenAI API call function
async function callOpenAI(messages, options = {}) {
    try {
        // This is a placeholder function - in actual implementation,
        // this would make an API call to OpenAI
        console.log("Calling OpenAI API with messages:", messages);
        
        // For demo purposes, return a placeholder response
        // In a real implementation, this would be:
        // const response = await fetch('https://api.openai.com/v1/chat/completions', {
        //     method: 'POST',
        //     headers: {
        //         'Content-Type': 'application/json',
        //         'Authorization': `Bearer ${apiKey}`
        //     },
        //     body: JSON.stringify({
        //         model: options.model || 'gpt-4',
        //         messages: messages,
        //         max_tokens: options.max_tokens || 800,
        //         temperature: options.temperature || 0.7
        //     })
        // });
        // const data = await response.json();
        // return data.choices[0].message.content;
        
        // Generate mock response for demo
        const type = messages[0].content.includes("RESUME") ? "RESUME" :
                   messages[0].content.includes("FINANCIAL") ? "FINANCIAL" :
                   messages[0].content.includes("SURVEY") ? "SURVEY" :
                   messages[0].content.includes("REPORT") ? "REPORT" : "DOCUMENT";
        
        // Check if the document likely has extraction issues
        const userContent = messages[messages.length - 1].content;
        const hasTextQualityIssues = userContent.includes("BT") && userContent.includes("ET") && userContent.includes("Tj");
        
        if (hasTextQualityIssues) {
            return "## Document Extraction Error\n\nThe text appears to contain PDF syntax and operators rather than proper document content. I'm seeing PDF operators like 'BT', 'ET', and 'Tj' which indicates the extraction process captured the PDF structure rather than the human-readable content.\n\nProper analysis cannot be performed on this extracted data as it doesn't represent the actual document content. Please try an alternative extraction method or tool that can properly separate the text content from the PDF structure.";
        }
        
        return "# Document Analysis Complete\n\nThis is a placeholder for the actual analysis that would be returned by the OpenAI API call. In a real implementation, this would contain a detailed analysis of the document based on its type and content.";
    } catch (error) {
        console.error("Error calling OpenAI API:", error);
        return "Error generating analysis: " + error.message;
    }
}
        // Utility: Generate UUID
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Auto-resize textarea on input
        messageInput.addEventListener("input", function() {
            this.style.height = "auto";
            this.style.height = (this.scrollHeight) + "px";
        });
    </script>
</body>
</html>